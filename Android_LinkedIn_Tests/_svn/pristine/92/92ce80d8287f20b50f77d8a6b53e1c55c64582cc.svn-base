<?xml version="1.0" encoding="UTF-8"?>
<Review id="vasily.gancharov">
  <ReviewIssue id="H70D3SQ8">
    <ReviewIssueMeta>
      <CreationDate format="yyyy-MM-dd :: HH:mm:ss:SSS z">2012-09-12 :: 15:44:38:192 MSK</CreationDate>
      <LastModificationDate format="yyyy-MM-dd :: HH:mm:ss:SSS z">2012-09-13 :: 11:13:57:773 MSK</LastModificationDate>
    </ReviewIssueMeta>
    <ReviewerId>alexander.makarov</ReviewerId>
    <AssignedTo>alexander.makarov</AssignedTo>
    <File line="235">src/com/linkedin/android/utils/HardwareActions.java</File>
    <Type>item.type.label.other</Type>
    <Severity>item.severity.label.normal</Severity>
    <Summary>scrollDownNTimes(int numberOfScrolls), scrollDownNTimes(int numberOfScrolls, int delayMs), scrollToBottomNTimes</Summary>
    <Description>/**
     * Scrolls screen down specified number of times. Stops scrolling if it is
     * not possible.
     * 
     * @param numberOfScrolls
     *            number of scrolls
     */
    public static void scrollDownNTimes(int numberOfScrolls) {
        Solo solo = DataProvider.getInstance().getSolo();
        for (int i = 0; i &lt; numberOfScrolls; i++) {
            if (!solo.scrollDown()) {
                return;
            }
        }
    }

    /**
     * Scrolls screen down specified number of times. Waits {@code delayMs}
     * (milliseconds) after each scroll.
     * 
     * @param numberOfScrolls
     *            number of scrolls
     * @param delayMs
     *            wait time after each scroll (in milliseconds)
     */
    public static void scrollDownNTimes(int numberOfScrolls, int delayMs) {
        Solo solo = DataProvider.getInstance().getSolo();
        for (int i = 0; i &lt; numberOfScrolls; i++) {
            solo.scrollDown();
            solo.sleep(delayMs);
        }
    }

    /**
     * Scrolls to the bottom of screen specified number of times. Waits
     * {@code delayMs} (milliseconds) each time after achieving of the bottom.
     * 
     * @param numberOfScrolls
     *            number of scrolls to the bottom
     * @param delayMs
     *            wait time after each achieving of the bottom (in milliseconds)
     */
    public static void scrollToBottomNTimes(int numberOfScrolls, int delayMs) {
        Solo solo = DataProvider.getInstance().getSolo();
        for (int i = 0; i &lt; numberOfScrolls; i++) {
            solo.scrollToBottom();
            solo.sleep(delayMs);
        }
    }</Description>
    <Annotation></Annotation>
    <Revision></Revision>
    <Resolution>item.resolution.label.validWontfix</Resolution>
    <Status>item.status.label.closed</Status>
  </ReviewIssue>
  <ReviewIssue id="H70F0C3S">
    <ReviewIssueMeta>
      <CreationDate format="yyyy-MM-dd :: HH:mm:ss:SSS z">2012-09-12 :: 16:37:55:912 MSK</CreationDate>
      <LastModificationDate format="yyyy-MM-dd :: HH:mm:ss:SSS z">2012-09-13 :: 11:14:05:773 MSK</LastModificationDate>
    </ReviewIssueMeta>
    <ReviewerId>alexander.makarov</ReviewerId>
    <AssignedTo>alexander.makarov</AssignedTo>
    <File></File>
    <Type>item.type.label.other</Type>
    <Severity>item.severity.label.normal</Severity>
    <Summary>searchMessageBySenderNameInActivity, isSenderName</Summary>
    <Description>/**
     * Searches message by {@code senderName} in list of currently loaded
     * messages (in current activity; does not scroll down to force 'Messages'
     * list update).
     * 
     * @param senderName
     *            message sender name
     * @return message sender name as {@code TextView} or &lt;b&gt;null&lt;/b&gt; if there
     *         is no such messages.
     */
    private TextView searchMessageBySenderNameInActivity(String senderName) {
        ArrayList&lt;TextView&gt; nonSenderNameTextViews = new ArrayList&lt;TextView&gt;();
        TextView senderNameTextView;

        do {
            senderNameTextView = ViewUtils.searchTextViewInActivity(senderName,
                    nonSenderNameTextViews, true);
            if (isSenderName(senderNameTextView)) {
                return senderNameTextView;
            }
            nonSenderNameTextViews.add(senderNameTextView);
        } while (null != senderNameTextView);
        return null;
    }

    /**
     * Checks whether specified {@code textView} is sender name.
     * 
     * @param textView
     *            {@code TextView} to check if sender name
     * @return &lt;b&gt;true&lt;/b&gt; if specified {@code textView} is sender name,
     *         &lt;b&gt;false&lt;/b&gt; otherwise.
     */
    private boolean isSenderName(TextView textView) {
        if (null == textView) {
            return false;
        }

        ViewParent textViewParent = textView.getParent();
        if (!(textViewParent instanceof RelativeLayout)) {
            return false;
        }
        RelativeLayout textViewParentLayout = (RelativeLayout) textViewParent;
        TextView senderName = ViewGroupUtils.getChildViewByIndexSafely(textViewParentLayout,
                SENDER_NAME_INDEX, TextView.class);
        if (textView != senderName) {
            return false;
        }
        ViewParent textViewParentLayoutParent = textViewParentLayout.getParent();
        Logger.logChildsHierarchy((LinearLayout) textViewParentLayoutParent);
        if (!(textViewParentLayoutParent instanceof LinearLayout)) {
            return false;
        }
        LinearLayout messageListItemLayout = (LinearLayout) textViewParentLayoutParent;
        ViewParent messagesList = messageListItemLayout.getParent();
        return messagesList instanceof ListView;
    }</Description>
    <Annotation></Annotation>
    <Revision></Revision>
    <Resolution>item.resolution.label.validWontfix</Resolution>
    <Status>item.status.label.closed</Status>
  </ReviewIssue>
  <ReviewIssue id="H70F1WJW">
    <ReviewIssueMeta>
      <CreationDate format="yyyy-MM-dd :: HH:mm:ss:SSS z">2012-09-12 :: 16:39:09:068 MSK</CreationDate>
      <LastModificationDate format="yyyy-MM-dd :: HH:mm:ss:SSS z">2012-09-13 :: 11:14:12:498 MSK</LastModificationDate>
    </ReviewIssueMeta>
    <ReviewerId>alexander.makarov</ReviewerId>
    <AssignedTo>alexander.makarov</AssignedTo>
    <File></File>
    <Type>item.type.label.other</Type>
    <Severity>item.severity.label.normal</Severity>
    <Summary>searchMessageBySenderName</Summary>
    <Description>/**
     * Searches message by {@code senderName} in messages list (scroll down
     * screen 10 times).
     * 
     * @param senderName
     *            message sender name
     * @return message sender name as {@code TextView} or &lt;b&gt;null&lt;/b&gt; if there
     *         is no such messages.
     */
    public TextView searchMessageBySenderName(String senderName) {
        final int numberOfTimesToScrollDown = 10;
        final int waitTimeWhenReachListEndSec = 3;

        Solo solo = getSolo();
        boolean isScreenCanBeScrolled = true;
        for (int i = 0; i &lt; numberOfTimesToScrollDown; i++) {
            TextView senderNameTextView = searchMessageBySenderNameInActivity(senderName);
            if (null != senderNameTextView) {
                return senderNameTextView;
            }
            if (!isScreenCanBeScrolled) {
                HardwareActions.delay(waitTimeWhenReachListEndSec);
            }
            isScreenCanBeScrolled = solo.scrollDown();
        }
        return null;
    }</Description>
    <Annotation></Annotation>
    <Revision></Revision>
    <Resolution>item.resolution.label.validWontfix</Resolution>
    <Status>item.status.label.closed</Status>
  </ReviewIssue>
</Review>